**** PROPERTIES SKAFFOLDER ****
{
    "forEachObj": "resource",
    "overwrite": true,
    "_partials": []
}
**** END PROPERTIES SKAFFOLDER ****
/**
 * 
 * 
  _____                      _              _ _ _     _   _     _        __ _ _      
 |  __ \                    | |            | (_) |   | | | |   (_)      / _(_) |     
 | |  | | ___    _ __   ___ | |_    ___  __| |_| |_  | |_| |__  _ ___  | |_ _| | ___ 
 | |  | |/ _ \  | '_ \ / _ \| __|  / _ \/ _` | | __| | __| '_ \| / __| |  _| | |/ _ \
 | |__| | (_) | | | | | (_) | |_  |  __/ (_| | | |_  | |_| | | | \__ \ | | | | |  __/
 |_____/ \___/  |_| |_|\___/ \__|  \___|\__,_|_|\__|  \__|_| |_|_|___/ |_| |_|_|\___|
 
 * DO NOT EDIT THIS FILE!! 
 * 
 *  TO CUSTOMIZE {{resource.name}}ModelGenerated.js PLEASE EDIT ../{{resource._entity.name}}Model.js
 * 
 *  -- THIS FILE WILL BE OVERWRITTEN ON THE NEXT SKAFFOLDER'S CODE GENERATION --
 * 
 */
// Database
import Database from "../../../classes/Database_{{capitalize db.name}}";
import mongoose, { Schema } from "mongoose";

// Logger
import Logger from "../../../classes/Logger";

const generatedModel = {
  /**
   * Init  schema
   */
  init() {
    const db = Database.getConnection();

    {{#notNull resource._entity}}
    /**
      * {{resource._entity.name}}
      */
    const {{lowercase resource._entity.name}}Schema = new mongoose.Schema({
      {{#each resource._entity._attrs}}
      {{name}}: {{#equal ../resource.name 'User'}}{{#equal name 'roles'}}[{{/equal}}{{/equal}}{
        type: "{{toJSType type}}"{{#required}}, 
        required: true{{/required}}{{#unique}},
        unique: true, {{/unique}}{{#if _enum}},
        enum: {{#joinObj _enum 'name'}}{{/joinObj}}, {{/if}}
      }{{#equal ../resource.name 'User'}}{{#equal name 'roles'}}]{{/equal}}{{/equal}},
      {{/each}}
      // RELATIONS
      {{#each resource._entity._relations}}
        {{#equal _ent1.name ../resource._entity.name}}
      {{name}}: {{#equal type 'm:m'}}[{{/equal}}{
        type: Schema.ObjectId{{#required}}, 
        required: true{{/required}},
        ref: "{{_ent2.name}}"
      }{{#equal type 'm:m'}}]{{/equal}},
        {{/equal}}
      {{/each}}
      
      
      // EXTERNAL RELATIONS
      /*
      {{#each resource._entity._relations}}{{#notEqual _ent1.name ../resource._entity.name}}{{name}}: {{#equal type 'm:m'}}[{{/equal}}{
        type: Schema.ObjectId{{#required}}, 
        required: true{{/required}},
        ref: "{{_ent1.name}}"
      }{{#equal type 'm:m'}}]{{/equal}},
      {{/notEqual}}{{/each}}*/
    });

    generatedModel.setModel(db.connection.model("{{capitalize resource._entity.name}}", {{lowercase resource._entity.name}}Schema));
    {{#equal resource._entity.name "User"}}
    generatedModel.createAdminUser();
    {{/equal}}
    {{/notNull}}

    return {{lowercase resource._entity.name}}Schema;
  },

  /**
   * Set Model
   */
  setModel: model => {
    generatedModel.model = model;
  },

  /**
   * Get model
   */
  getModel: () => {
    return generatedModel.model;
  },

  // Start queries
    
  {{#notNull resource._entity}}

  // CRUD METHODS

  {{#each resource._services}}
    {{#equal crudAction 'list'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}() {
    return await generatedModel.model.find(){{#equal ../resource._entity.name "User"}}.select("-password"){{/equal}};
  },
    {{/equal}}
    {{#equal crudAction 'get'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}(id) {
    return await generatedModel.model.findOne({ _id : id }){{#equal ../resource._entity.name "User"}}.select("-password"){{/equal}};
  },
    {{/equal}}
    {{#equal crudAction 'update'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}(item) { {{#equal ../resource._entity.name "User"}}
    delete item.password;
    {{/equal}}

    return await generatedModel.model.findOneAndUpdate({ _id: item._id }, item, {'new': true});
  },
    {{/equal}}
    {{#equal crudAction 'delete'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}(id) {
    return await generatedModel.model.findByIdAndRemove(id);
  },
    {{/equal}}
    {{#equal crudAction 'create'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}(item) {
    const obj = new generatedModel.model(item);
    return await obj.save();
  },
    {{/equal}}
    {{#startWith crudAction 'findBy'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}(key) {
    return await generatedModel.model.find({ '{{#subStr name 6 }}{{/subStr}}' : key});
  },
    {{/startWith}}
    {{#startWith crudAction 'get'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}(id) {
    return await generatedModel.model.findOne({ _id : id}).populate("{{#subStr name 3 }}{{/subStr}}")
  },
    {{/startWith}}
  {{/each}}{{/notNull}}


  {{#equal resource._entity.name "User"}}

  // Start custom queries User

  /**
   * Get User by username e password
   */
  getByUsernameAndPassword: async (username, password) => {
    // CUSTOMIZE THIS FUNCTION
    // if you want to change login method

    let user = await generatedModel.model
      .findOne({
        username: username,
        password: password
      })
      .lean();
    if (user) user.password = undefined;
    return user;
  },

  /**
   * Update password
   */
  updatePassword: async (idUser, password) => {
    let user = await generatedModel.model.findOneAndUpdate({ _id: idUser }, {
      password: password
    });
    return user;
  },

  /**
   * Create ADMIN user if it not exists
   */
  createAdminUser: async () => {
    const count = await generatedModel.model.collection.countDocuments();
    if (count == 0) {
      Logger.info("Create admin user");
      var admin = new generatedModel.model({
        username: "admin",
        password:
          "62f264d7ad826f02a8af714c0a54b197935b717656b80461686d450f7b3abde4c553541515de2052b9af70f710f0cd8a1a2d3f4d60aa72608d71a63a9a93c0f5",
        roles: ["ADMIN"]
      });
      return await admin.save();
    }
  }
  {{/equal}}
};

export default generatedModel;
